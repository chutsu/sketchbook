<html class=" mzkzve idc0_350"><!-- Mirrored from www.lighthouse3d.com/opengl/viewfrustum/ by HTTrack Website Copier/3.x [XR&CO'2006], Thu, 18 Jan 2007 07:56:07 GMT --><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252">   
	<meta name="Author" content="Antonio Ramires Fernandes">
	<meta name="Description" content="A tutorial on View Frustum Culling for OpenGL. A technique to increase the performance of a graphical application">
	<meta name="KeyWords" content="OpenGL, tutorial, View frustum culling">
	<title>OpenGL @ Lighthouse 3D - View Frustum Culling Tutorial </title>
</head>

<body>
    <h1>View Frustum Culling Tutorial</h1>


<h1>
    <center>View Frustum Culling Tutorial</center>
</h1>
<br>
Quelle: <a href="http://www.lighthouse3d.com/opengl/viewfrustum/">Lighthouse 3D</a>
<br>


<h2>
<center>
			Introduction
</center>
</h2>
<br>
In order to visualize a scene from different angles a virtual camera is 
often used. The virtual camera setup, commonly done with <a href="http://www.lighthouse3d.com/opengl/glut/index.php?3"><i>gluPerspective</i></a> and <a href="http://www.lighthouse3d.com/opengl/glut/index.php?3"><i>gluLookAt</i></a> functions, determines what is visible on screen.
<p>
The view frustum is the volume that contains everything that is 
potentially (there may be occlusions) visible on the screen. This volume
 is defined according to the camera's settings, and when using a 
perspective projection takes the shape of a truncated pyramid.
</p><p>
</p><center>
<img src="View%20Frustum%20Culling%20Tutorial_files/vf.gif" width="405" height="203">
</center>
<p>
The apex of the pyramid is the camera position and the base of the 
pyramid is the far plane. The pyramid is truncated at the near plane, 
hence the name frustum. 
</p><p>
All the stuff that will potentially be visible on screen is inside, at 
least partially, the truncated pyramid, so there is no need to try and 
render what is outside the frustum, since it won't be visible anyway. 
</p><p>
</p><center>
<img src="View%20Frustum%20Culling%20Tutorial_files/culling.gif" width="348" height="205">
</center>
<p>
In the figure above all the green stuff (totally inside the view 
frustum) and all the yellow stuff (partially inside) would be rendered, 
whereas the red stuff will not be rendered. Note that the green sphere 
is not visible (it is occluded by the yellow ellipse), but it will be 
rendered anyway because it is inside the view frustum.
</p><p>
The goal of view frustum culling is therefore to be able to identify 
what is inside the frustum (totally or partially), and cull everything 
that is not inside. Only the stuff that is inside the frustum is sent to
 the graphics hardware. In the end, all that is asked of the graphics 
hardware is to render what is potentially visible, saving on the 
processing of all those vertices that are not visible anyway. 
Furthermore, this can potentially improve the performance of the 
application since only the vertices that are part of the visible part of
 the 3D world are kept on the graphics card memory, and these are more 
likely to fit than the whole 3D world.
</p><p>
This test makes sense if the part of the 3D world that is inside the 
frustum is significantly smaller than the world itself. But what does 
significantly smaller mean? That depends on the application. In the 
extreme case when the whole 3D world is always visible, view frustum 
culling is just a waste of time because there is nothing to cull. But 
since this culling technique is so easy to implement and the performance
 benefits can be very significant it is worth a try.
</p><p>

</p><h2>
<center>
			Shape of the View Frustum
</center>
</h2>
<br>
In this section the shape of the view frustum is related to the 
instructions issued by the OpenGL application. It is assumed that a 
perspective projection is defined using the <a href="http://www.lighthouse3d.com/opengl/glut/index.php?3"><i>gluPerspective</i></a> function, and that the camera is positioned with the <a href="http://www.lighthouse3d.com/opengl/glut/index.php?3"><i>gluLookAt</i> </a>function. 
<p>
First let's recall the parameters (all floats) of these functions:
</p><dl>
<li>gluPerspective(fov, ratio, nearDist, farDist);<p></p></li>
<li>gluLookAt(px,py,pz,  lx,ly,lz,  ux,uy,uz)</li>
</dl>
The apex of the pyramid is the position of the camera (<i>px,py,pz</i>). A view <a href="http://www.lighthouse3d.com/opengl/maths/index.php?lines">ray</a> can be computed with direction <i>d</i> = <i>l</i> - <i>p</i>, where <i>l</i> = (<i>lx,ly,lz</i>) and origin <i>p</i> = (<i>px,py,pz</i>). The near and far planes are perpendicular to the view ray and are placed at distances <i>nearDist</i> and <i>farDist</i>.
 The rectangular boundaries of the view frustum in those planes, near 
and far, have dimensions that are a function of the distance and the <i>fov</i> (vertical field of view), and <i>ratio</i> (ratio between the horizontal and vertical fields of view).
<p>
The height and width of the rectangular boundary on the near plane are defined as follows:
</p><pre><code>
	Hnear = 2 * tan(<i>fov / 2</i>) * <i>nearDist</i>
	
	Wnear = Hnear * <i>ratio</i>
</code>
</pre>
The same reasoning can be applied to the far plane:
<pre><code>
	Hfar = 2 * tan(<i>fov / 2</i>) * <i>farDist</i>
	
	Wfar = Hfar * <i>ratio</i>
</code>
</pre>
<p>
</p><center>
<img src="View%20Frustum%20Culling%20Tutorial_files/vf2.gif" width="600" height="260">
</center>
<p>
In order to perform view frustum culling, two steps are required:
</p><dl>
<li>Extract the frustum volume information - this has to be done every 
time the frustum changes, i.e., when the camera moves or when the 
perspective changes<p></p></li>
<li>Test the objects against the frustum's volume to determine whether 
to cull or not - this has to be performed for every object in every 
frame. If the culling status of each object is kept from frame to frame 
then the test itself may be done only when the camera moves, i.e. when 
the frustum is updated or perspective changes.</li>
</dl>
The <a href="https://cgvr.cs.uni-bremen.de/teaching/cg_literatur/lighthouse3d_view_frustum_culling/examples/frustumDemo.zip">demo</a>
 opens three windows: the user camera view, a window where the user 
camera and the view frustum can be seen from the top, and finally a 
third with a view from the right. The spheres inside the frustum are 
shown in green, the ones that intersect the frustum are drawn in yellow,
 and the ones outside the frustum are rendered in red.
<p>
</p><center>
<img src="View%20Frustum%20Culling%20Tutorial_files/demo.gif" width="657" height="354">
</center>
<p>
</p><p>





</p><h2>
<center>
			Geometric Approach - Extracting the Planes
</center>
</h2>
<br>
The geometric approach operates in world space and uses the information from the <a href="https://cgvr.cs.uni-bremen.de/teaching/cg_literatur/lighthouse3d_view_frustum_culling/index1ec6.html?defvf">shape</a>
 of the view frustum to extract the six planes that define the 
boundaries of the frustum's volume: near, far, top, bottom, left and 
right.
<p>
The planes are defined such that the normal points towards the inside of
 the view frustum. Testing if an object is inside the view frustum is 
performed by computing on which side of the plane the object resides. 
This can be done computing the <a href="http://www.lighthouse3d.com/opengl/maths/index.php?planes">signed distance</a>
 from the point ot the plane. If it is on the side that the normal is 
pointing, i.e. the signed distance is positive, then it is on the right 
side of the respective plane. If an object is on the right side of all 
six planes then the object is inside the frustum. 
</p><p>
In this section the computation of the six planes that define the 
frustum is provided. Testing will be detailed on the next sections.
</p><p>
An approach is to first determine the eight points that define the 
corners of the view frustum, and then use these points to define the six
 planes. 
</p><p>
The following figure shows the above mentioned points that may be used to compute the six planes.
</p><center>
<img src="View%20Frustum%20Culling%20Tutorial_files/vfpoints.gif" width="407" height="204">
</center>
<p>
The notation used to define the points is as follows: the first letter 
indicates if the point is on the near (n) or far plane (f); the second 
letter states if the point is at the top (t) or bottom (b); and the 
third letter indicates left (l) or right (r). 
</p><p>
Lets recall the information that was collected in the <a href="https://cgvr.cs.uni-bremen.de/teaching/cg_literatur/lighthouse3d_view_frustum_culling/index1ec6.html?defvf">previous</a> section:
</p><dl>
<li>p - the camera position</li>
<li>d - a vector with the direction of the camera's view ray. In here it is assumed that this vector has been normalized</li>
<li>nearDist - the distance from the camera to the near plane</li>
<li> Hnear - the "height" of the near plane</li>
<li> Wnear - the "width" of the near plane</li>
<li>farDist - the distance from the camera to the far plane</li>
<li> Hfar - the "height" of the far plane</li>
<li> Wfar - the "width" of the far plane</li>
</dl>
A couple more unit vectors are required, namely the <i>up</i> vector and the <i>right</i>
 vector. The former is obtained by normalizing the vector (ux,uy,uz) 
(the components of this vector are the last parameters of the <i>gluLookAt</i> function); the latter is obtained with the cross product between the <i>up</i> vector and the <i>d</i> vector.
<p>
The following figure shows how to obtain the point on the top left side of the far plane, point <i>ftl</i>.
</p><center>
<img src="View%20Frustum%20Culling%20Tutorial_files/vfpoints2.gif" width="490" height="254">
</center>
<p>
To compute <i>ftl</i> all is required is vector math:  
</p><pre><code>
	fc = p + d * farDist 
	
	ftl = fc + (up * Hfar/2) - (right * Wfar/2)
</code></pre>
<p>
The remaining points are defined as:
</p><pre><code>
	ftr = fc + (up * Hfar/2) + (right * Wfar/2)
	fbl = fc - (up * Hfar/2) - (right * Wfar/2)
	fbr = fc - (up * Hfar/2) + (right * Wfar/2)

	nc = p + d * nearDist 
	
	ntl = nc + (up * Hnear/2) - (right * Wnear/2)
	ntr = nc + (up * Hnear/2) + (right * Wnear/2)
	nbl = nc - (up * Hnear/2) - (right * Wnear/2)
	nbr = nc - (up * Hnear/2) + (right * Wnear/2)
</code></pre>
A <a href="http://www.lighthouse3d.com/opengl/maths/index.php?planes">plane</a>
 can be defined with three points. For instance, to define the far plane
 the following points can be used: ftl, ftr, and fbr. It is advisable to
 make sure that the normals are oriented consistently, for instance that
 all are directed towards the interior of the view frustum, see the <a href="http://www.lighthouse3d.com/opengl/maths/index.php?planes">plane</a> section on the <a href="http://www.lighthouse3d.com/opengl/maths/">maths tutorial</a>. 
<p>
An optimization can be performed using this approach to extract the near
 and far planes. A plane can be defined with a normal and a point, and 
for those planes these are known based on the camera definition.
</p><p>
The near plane can be defined with <i>d</i> as a normal, and <i>nc</i> as a point on the plane. As for the far plane the normal is -<i>d</i> and the point is <i>fc</i>.
</p><p>
The other planes can also be computed in a more efficient manner, namely
 by using a normal vector and a point to define a plane. The following 
code provides the normal for the right plane. As for the point, the 
camera position, <i>p</i> is a point in all top, bottom, left and right planes (considering a perspective projection). 
</p><pre><code>
	nc = p + d * nearDist
	fc = p + d * farDist
	
	a = (nc + right * Wnear / 2) - p
	a.normalize();
	normalRight = up * a
</code></pre>

<center>
<img src="View%20Frustum%20Culling%20Tutorial_files/planenormal.gif" width="338" height="185">
</center>
<p>
Both <i>up</i> and <i>a</i> are vectors that belong to the right plane, so their cross product will provide a normal for the plane.
</p><p>






</p><h2>
<center>
			Geometric Approach - Implementation
</center>
</h2>
<br>
A class to implement the frustum functionality is now presented. Note 
that the code itself is not optimized in any way, as the goal is only to
 serve as the tutorial companion. The class contains an array of six 
planes, plus other variables such as the 8 corners of the frustum and 
the camera definitions. Only the planes are needed for the culling 
operation, but the remaining variables are useful for debug and 
visualization purposes.
<p>
<b>The class header file</b>
</p><pre><code>
class FrustumG {

private:

	enum {
		TOP = 0, BOTTOM, LEFT,
		RIGHT, NEARP, FARP
	};

public:

	static enum {OUTSIDE, INTERSECT, INSIDE};

	Plane pl[6];

	Vec3 ntl,ntr,nbl,nbr,ftl,ftr,fbl,fbr;
	float nearD, farD, ratio, angle,tang;
	float nw,nh,fw,fh;

	FrustumG::FrustumG();
	FrustumG::~FrustumG();

	void setCamInternals(float angle, float ratio, float nearD, float farD);
	void setCamDef(Vec3 &amp;p, Vec3 &amp;l, Vec3 &amp;u);
	int pointInFrustum(Vec3 &amp;p);
	int sphereInFrustum(Vec3 &amp;p, float raio);
	int boxInFrustum(AABox &amp;b);

};
</code>
</pre>
<p>
<b>The Methods: setCamInternals</b>
</p><p>
This function takes exactly the same parameters as the function <i>gluPerspective</i>. Each time the perspective definitions change, for instance when a window is resized, this function should be called as well.
</p><pre><code>
#define ANG2RAD 3.14159265358979323846/180.0

void FrustumG::setCamInternals(float angle, float ratio, float nearD, float farD) {

	// store the information
	this-&gt;ratio = ratio;
	this-&gt;angle = angle;
	this-&gt;nearD = nearD;
	this-&gt;farD = farD;

	// compute width and height of the near and far plane sections
	tang = (float)tan(ANG2RAD * angle * 0.5) ;
	nh = nearD * tang;
	nw = nh * ratio; 
	fh = farD  * tang;
	fw = fh * ratio;


}
</code>
</pre>
<p>
The function stores all the information, and computes the width and 
height of the rectangular sections of the near and far plane and stores 
them in <i>nh</i> (near height), <i>nh</i> (near width), <i>fh</i> (far height), and <i>fw</i> (far width).
</p><p>
<b>The Methods: setCamDef</b>
</p><p>
This function takes three vectors that contain the information for the <i>gluLookAt</i>
 function: the position of the camera, a point to where the camera is 
pointing and the up vector. Each time the camera position or orientation
 changes, this function should be called as well.
</p><pre><code>
void FrustumG::setCamDef(Vec3 &amp;p, Vec3 &amp;l, Vec3 &amp;u) {

	Vec3 dir,nc,fc,X,Y,Z;

	// compute the Z axis of camera
	// this axis points in the opposite direction from 
	// the looking direction
	Z = p - l;
	Z.normalize();

	// X axis of camera with given "up" vector and Z axis
	X = u * Z;
	X.normalize();

	// the real "up" vector is the cross product of Z and X
	Y = Z * X;

	// compute the centers of the near and far planes
	nc = p - Z * nearD;
	fc = p - Z * farD;

	// compute the 4 corners of the frustum on the near plane
	ntl = nc + Y * nh - X * nw;
	ntr = nc + Y * nh + X * nw;
	nbl = nc - Y * nh - X * nw;
	nbr = nc - Y * nh + X * nw;

	// compute the 4 corners of the frustum on the far plane
	ftl = fc + Y * fh - X * fw;
	ftr = fc + Y * fh + X * fw;
	fbl = fc - Y * fh - X * fw;
	fbr = fc - Y * fh + X * fw;

	// compute the six planes
	// the function set3Points assumes that the points
	// are given in counter clockwise order
	pl[TOP].set3Points(ntr,ntl,ftl);
	pl[BOTTOM].set3Points(nbl,nbr,fbr);
	pl[LEFT].set3Points(ntl,nbl,fbl);
	pl[RIGHT].set3Points(nbr,ntr,fbr);
	pl[NEARP].set3Points(ntl,ntr,nbr);
	pl[FARP].set3Points(ftr,ftl,fbl);
}
</code>
</pre>
<p>
The function computed the eight corners of the frustum and the six planes according to the algorithm defined in the previous <a href="https://cgvr.cs.uni-bremen.de/teaching/cg_literatur/lighthouse3d_view_frustum_culling/index8ea3.html?gaplanes">section</a>.
</p><p>
The following (more efficient) alternative may be used to replace the 
computation of the eight corners and the six planes in the function 
above.
</p><pre><code>
	pl[NEARP].setNormalAndPoint(-Z,nc);
	pl[FARP].setNormalAndPoint(Z,fc);

	Vec3 aux,normal;

	aux = (nc + Y*nh) - p;
	aux.normalize();
	normal = aux * X;
	pl[TOP].setNormalAndPoint(normal,nc+Y*nh);

	aux = (nc - Y*nh) - p;
	aux.normalize();
	normal = X * aux;
	pl[BOTTOM].setNormalAndPoint(normal,nc-Y*nh);
	
	aux = (nc - X*nw) - p;
	aux.normalize();
	normal = aux * Y;
	pl[LEFT].setNormalAndPoint(normal,nc-X*nw);

	aux = (nc + X*nw) - p;
	aux.normalize();
	normal = Y * aux;
	pl[RIGHT].setNormalAndPoint(normal,nc+X*nw);
</code>
</pre>

<p>





</p><h2>
<center>
			Geometric Approach - Testing Points and Spheres
</center>
</h2>
<br>
Once the planes have been extracted, it is possible to find out if a 
point is inside or outside the frustum. Computing the signed distance 
tells us which side of the plane the point is on. Assuming that the  
planes' normals are pointing inwards, then if the <a href="http://www.lighthouse3d.com/opengl/maths/index.php?planes">signed distance</a> is negative the point is outside the frustum. Otherwise the point is on the right side of the plane.
<p>
The following function of the class FrustumG shows a possible implementation. The parameter is the point to be tested.
</p><pre><code>
	int FrustumG::pointInFrustum(Vec3 &amp;p) {

		int result = INSIDE;
		for(int i=0; i &lt; 6; i++) {

			if (pl[i].distance(p) &lt; 0)
				return OUTSIDE;
		}
		return(result);

	}
</code>
</pre>
Notice the early way out of the function. If a point is inside the 
frustum it must be on the right side of every plane, therefore in order 
to accept a point, all six planes must be tested. However, to reject a 
point all that is needed is for the point to be on the wrong side of a 
single plane. 
<p>
To test an object, all vertices could be tested. If all the vertices are
 on the wrong side of a plane then the object would be outside the 
frustum. However this test may be too time consuming for large objects. 
Consider a car with 10000 polygons, in the worst case scenario 10000 
tests would have to be done to reach a conclusion of the whereabouts of 
the car relative to the frustum.
</p><p>
In this case it is very likely that asking the graphics hardware to 
render the car would have been faster than performing all the tests and 
then, on top of it, maybe having to render the car anyway.
</p><p>
Hence for complex objects testing all vertices is not an option, instead
 bounding volumes are used. Several types of bounding volumes exist, and
 two of the most popular, for their simplicity, are spheres and boxes.
</p><p>
Finding a sphere that contains all the vertices of the car is an easy 
task (the average of the vertices is the center of the sphere, and the 
radius is the distance to the farthest vertex), and testing a sphere is 
extremelly fast as it will be shown next.
</p><p>
There is a tradeof in here: simplicity of the test implies faster but 
less accurate testing: the car may be outside the frustum, but the 
sphere may be partially inside. Less tests imply that potentially stuff 
that is outside of the frustum will be sent to the graphics hardware. 
But as long as there is a good match between the bounding volume and the
 object, this strategy does compensate.
</p><p>
<b>Spheres</b>
</p><p>
Testing spheres is similar to testing points, except for the radius of 
the sphere. A sphere is out of the frustum if its center is on the wrong
 side of at least one plane and the distance to the plane is greater 
than the radius of the sphere. If the absolute value of the distance is 
smaller than the radius then the sphere intersects the plane, meaning 
that the sphere is partially on the right side of the plane. Otherwise 
the sphere is completely on the right side of the plane.
</p><pre><code>
int FrustumG::sphereInFrustum(Vec3 &amp;p, float radius) {

	float distance;
	int result = INSIDE;
	
	for(int i=0; i &lt; 6; i++) {
		distance = pl[i].distance(p);
		if (distance &lt; -radius)
			return OUTSIDE;
		else if (distance &lt; radius)
			result =  INTERSECT;
	}
	return(result);
}
</code>
</pre>
The function receives as parameters the center and radius of the sphere and tests the distance against all planes. 

<p>



</p><h2>
<center>
			Geometric Approach - Testing Boxes
</center>
</h2>
<br>

Testing a box is a little bit trickier than spheres and points. A simple
 way to do this is to test the eight corners of the box. A naive 
approach would be to consider that the box is outside of the frustum if 
all the points are outside the frustum. However the simple diagram shows
 that this is not always the case.
<p>
</p><center>
<img src="View%20Frustum%20Culling%20Tutorial_files/vfbox.gif" width="350" height="209">
</center>
<p>
The points of the yellow box are all outside the frustum, yet the box is
 partially inside the frustum, hence it can't be rejected. A safe way of
 solving the problem is to reject a box if, and only if, all points are 
on the wrong side of the <b>same</b> plane. In the figure above it is clear that there is no such plane for the yellow box.
</p><p>
There is a nasty side effect to this solution: in the figure below, the 
orange box, although totally outside the frustum will not be rejected 
according to this test. Two options are available: accept these boxes 
since the cost of testing should be kept to a minimum, or do some 
further testing. 
</p><p>
In here the first solution is taken, hence some boxes outside the 
frustum are accepted, in order to keep the cost of testing to a minimum (<a href="https://cgvr.cs.uni-bremen.de/teaching/cg_literatur/lighthouse3d_view_frustum_culling/index5740.html?refs">Assarsson and Moller</a> report that they found no observable penalty in the rendering when skipping further tests).
</p><p>
</p><center>
<img src="View%20Frustum%20Culling%20Tutorial_files/vfbox2.gif" width="375" height="253">
</center>
<p>
</p><pre><code>
int FrustumG::boxInFrustum(Box &amp;b) {

	int result = INSIDE, out,in;

	// for each plane do ...
	for(int i=0; i &lt; 6; i++) {

		// reset counters for corners in and out
		out=0;in=0;
		// for each corner of the box do ...
		// get out of the cycle as soon as a box as corners
		// both inside and out of the frustum
		for (int k = 0; k &lt; 8 &amp;&amp; (in==0 || out==0); k++) {
		
			// is the corner outside or inside
			if (pl[i].distance(b.getVertex(k)) &lt; 0)
				out++;
			else
				in++;
		}
		//if all corners are out
		if (!in)
			return (OUTSIDE);
		// if some corners are out and others are in	
		else if (out)
			result = INTERSECT;
	}
	return(result);

 }
</code>
</pre>
This function is clearly more complex since for each plane, the eight 
corners of the box may have to be tested. Note that two new variables <i>in</i> and <i>out</i>
 are declared. These variables track, for each plane the number of 
corners that fall on each side of the plane. If all points are on the 
wrong side of the plane then <i>in</i> is going to be zero and the Box 
can be immediately rejected. If the corners fall on both sides of the 
plane, then the box is potentially intersecting the frustum. A box will 
be inside the frustum if for all planes, it is not on the wrong side of 
the planes, and it is not intersecting any plane.
<p>
Testing the points against a plane stops as soon as there are points on 
both sides of the plane (notice the stop condition on the for cycle), 
meaning that the box is intersecting the plane.



</p><p>




</p><h2>
<center>
			Geometric Approach - Testing Boxes II	
</center>
</h2>
<br>
Box testing can be optimized, up to a certain extent, by testing only 
two of its vertices, namely the "positive vertex" and the "negative 
vertex" (aka the maximum vertex and the minimum vertex).
<p>
Testing a single vertex is enough for the cases where the box is 
outside, and the second vertex needs only to be tested if one requires 
distinguishing between boxes totally inside and boxes partially inside 
the view frustum.
</p><p>
So what are these vertices? And how hard is it to find them?
</p><p>
Consider a plane and its normal. The positive vertex is the vertex from 
the box that is further along the normal's direction. The negative 
vertex is the opposite vertex.
</p><p>
</p><center>
<img src="View%20Frustum%20Culling%20Tutorial_files/vfaabox.gif" width="240" height="231">
</center>
<p>
If the p-vertex is on the wrong side of the plane, the box can be 
immediately rejected, as it falls completely outside the frustum. On the
 other hand, if the p-vertex is on the right side of the plane, then 
testing the whereabouts of the n-vertex tells if the box is totally on 
the right side of the plane, or if the box intersects the plane.
</p><p>
As to how hard it is to find them lets consider two cases: Axis Aligned 
Boxes (AAB), and Oriented Boxes (OB). In the first case, AAB, it is very
 easy and computationally inexpensive to find them. 
</p><p>
Assume a AAB that has its components <i>x</i>,<i>y</i>,and <i>z</i> varying between <i>xmin</i> and <i>xmax</i>; <i>ymin</i> and <i>ymax</i>; and <i>zmin</i> and <i>zmax</i>. The components of the positive vertex <i>p</i> are selected as follows:
</p><pre><code>
	p = (xmin,ymin,zmin)
	if (normal.x &gt;= 0)
		p.x = xmax;
	if (normal.y &gt;=0))
		p.y = ymax;
	if (normal.z &gt;= 0)
		p.z = zmax:
</code>
</pre>
The negative vertex <i>n</i> follows the opposite rule:
<pre><code>
	n = (xmax,ymax,zmax)
	if (normal.x &gt;= 0)
		n.x = xmin;
	if (normal.y &gt;=0))
		n.y = ymin;
	if (normal.z &gt;= 0)
		n.z = zmin:
</code>
</pre>
If the box is not axis aligned, i.e. an OB, then it is more expensive to
 find these two special vertices. An approach presented by <a href="https://cgvr.cs.uni-bremen.de/teaching/cg_literatur/lighthouse3d_view_frustum_culling/index5740.html?refs">Moller and Haines</a> is to transform the normal into the box's space. So consider the box's three axis, <i>bx</i>, <i>by</i> and <i>bz</i>. To transform the normal into the box's space just perform the <a href="http://www.lighthouse3d.com/opengl/maths/index.php?projection">projections</a> of the normal onto these axes:
<p>
</p><pre><code>
	nb = (bx . n, by . n, bz . n)
</code>
</pre>
This new normal in the box's space, <i>nb</i>, is used to determine the p-vertex and n-vertex. For an OB, the test implies three <a href="http://www.lighthouse3d.com/opengl/maths/index.php?innerproduct">dot products</a>,
 plus the testing itself that requires one or two distance computations.
 Still for boxes outside the frustum it should be faster than testing 
the eight vertices of the box.
<p>

Given both p-vertex and n-vertex, the code to find the position of an axis aligned box in a frustum is as follows:
</p><pre><code>
int FrustumG::boxInFrustum(AABox &amp;b) {

	int result = INSIDE;
	//for each plane do ...
	for(int i=0; i &lt; 6; i++) {

		// is the positive vertex outside?
		if (pl[i].distance(b.getVertexP(pl[i].normal)) &lt; 0)
			return OUTSIDE;
		// is the negative vertex outside?	
		else if (pl[i].distance(b.getVertexN(pl[i].normal)) &lt; 0)
			result =  INTERSECT;
	}
	return(result);

 }
</code>
</pre>
<p>



</p><h2>
<center>
			Geometric Approach - Source Code
</center>
</h2>
<br>
The <a href="https://cgvr.cs.uni-bremen.de/teaching/cg_literatur/lighthouse3d_view_frustum_culling/examples/frustum.zip">zip</a>
 file contains the source code and a VC 6.0 project. The project 
contains all classes that are required to run the test, and allows 
testing with points, spheres, and axis aligned bounding boxes. Try it 
and see the difference between the frames per second achieved with and 
without frustum culling.
<p>
Note: the fps counter is only altered once per second, so keep your fingers on a leash :-)
</p><p>
As usual the source code is provided as a companion for this tutorial, 
and it could be optimized in many ways. Also there is no guarantee that 
it is bug free, or that it will run everywhere. 
</p><p>
Having said this, if you find a bug, or some way to improve this 
(without much work :), or even if you create a port to some other 
operating system, please let me know.
</p><p>




</p><h2>
<center>
			Clip Space Approach - Extracting the Planes
</center>
</h2>
<br>
In here another approach to extract the view frustum planes is presented based on the properties of clip space. 
<p>
Consider a point <i>p</i> =(<i>x,y,z,1</i>) on the 3D world. Consider also a modelview matrix <i>M</i> and a projection matrix <i>P</i>. The point <i>p</i> is transformed by matrices <i>M</i> and <i>P</i> as point <i>pc</i> =(<i>xc,yc,zc,wc</i>) in clip space using:
</p><p>
</p><center>
<img src="View%20Frustum%20Culling%20Tutorial_files/cseq1.gif" width="156" height="48">
</center>
<p>
The point <i>pc</i> is in homogeneous coordinates, and when normalised becomes <i>pcn</i>: 
</p><p>
</p><center>
<img src="View%20Frustum%20Culling%20Tutorial_files/cseq2.gif" width="234" height="44">
</center>
<p>
In normalised clip space the view frustum is an axis aligned box centered in the origin, and bounded by the following planes:
</p><pre><dl>
<li>Left Plane:   x' = -1</li>
<li>Right Plane:  x' =  1</li>
<li>Top Plane:    y' =  1</li>
<li>Bottom Plane: y' = -1</li>
<li>Near Plane:   z' = -1</li>
<li>Far Plane:    z' =  1</li>
</dl>
</pre>
This implies that the point <i>pcn</i> =(<i>x',y',z'</i>) is inside the view frustum if:
<p>
</p><center>
<img src="View%20Frustum%20Culling%20Tutorial_files/cseq3.gif" width="121" height="71">
</center>
<p>
Then the point <i>pc</i>, in non-normalized coordinates, must obbey the following conditions in order to be inside the view frustum:
</p><p>
</p><center>
<img src="View%20Frustum%20Culling%20Tutorial_files/cseq4.gif" width="136" height="70">
</center>
<p>
Based on this information it is possible to extract the six planes, in 
world coordinates, that bound the view frustum. The point <i>pc</i> is on the "right" side of the left plane if
</p><p>
</p><center>
<img src="View%20Frustum%20Culling%20Tutorial_files/cseq5.gif" width="117" height="19">
</center>
<p>
Consider p and A=MP as described below
</p><p>
</p><center>
<img src="View%20Frustum%20Culling%20Tutorial_files/cseq6.gif" width="244" height="128">
</center>
<p>
Then <i>xc</i> and <i>wc</i> can be defined as a function of <i>p</i> = (<i>x,y,z,w</i>), and <i>A</i>. 
</p><p>
</p><center>
<img src="View%20Frustum%20Culling%20Tutorial_files/cseq7.gif" width="275" height="49">
</center>
<p>
Therefore the following inequation must be true if <i>p</i> is on the right side of the left plane.
</p><p>
</p><center>
<img src="View%20Frustum%20Culling%20Tutorial_files/cseq8.gif" width="429" height="21">
</center>
<p>
A little algebric manipulation gives
</p><p>
</p><center>
<img src="View%20Frustum%20Culling%20Tutorial_files/cseq9.gif" width="455" height="46">
</center>
<p>
So the left plane (Ax+By+Cz+D=0) is defined as:
</p><p>
</p><center>
<img src="View%20Frustum%20Culling%20Tutorial_files/cseq10.gif" width="178" height="119">
</center>
<p>
where <i>col1</i> and <i>col4</i> are the first and forth columns of matrix A, respectively.
</p><p>
If the only objective is to find out if a point is inside or outside of the frustum then the <a href="http://www.lighthouse3d.com/opengl/maths/index.php?planes">plane</a>
 as defined is ok. However when testing spheres, which require computing
 the distance from the center of the sphere to the plane, it is 
advisable to <a href="http://www.lighthouse3d.com/opengl/maths/index.php?planes">normalize the plane</a>.
</p><p>
The right plane can be obtained in a similar manner:
</p><p>
</p><center>
<img src="View%20Frustum%20Culling%20Tutorial_files/cseq11.gif" width="395" height="75">
</center>
<p>
The following coefficients are obtained for the right plane:
</p><p>
</p><center>
<img src="View%20Frustum%20Culling%20Tutorial_files/cseq12.gif" width="188" height="118">
</center>
<p>
The remaining planes are obtained as follows:
</p><dl><li>Bottom Plane</li></dl>
<p>
</p><center>
<img src="View%20Frustum%20Culling%20Tutorial_files/cseq13.gif" width="187" height="169">
</center>
<p>
</p><dl><li>Top Plane</li></dl>
<p>
</p><center>
<img src="View%20Frustum%20Culling%20Tutorial_files/cseq14.gif" width="191" height="169">
</center>
<p>
</p><dl><li>Near Plane</li></dl>
<p>
</p><center>
<img src="View%20Frustum%20Culling%20Tutorial_files/cseq15.gif" width="185" height="166">
</center>
<p>
</p><dl><li>Far Plane</li></dl>
<p>
</p><center>
<img src="View%20Frustum%20Culling%20Tutorial_files/cseq16.gif" width="189" height="171">
</center>
<p>&nbsp;
</p><p>
</p><p>





</p><h2>
<center>
			Clip Space Approach - Implementation Details
</center>
</h2>
<br>
The following function, from class FrustumG, performs the plane 
extraction as described above, assuming that the matriz A=M*P is given 
as a parameter:
<pre><code>
#define m(row,col)  m[col*4+row-5]

void FrustumG::setFrustum(float *m) {

	pl[NEARP].setCoefficients(
				 m(3,1) + m(4,1),
				 m(3,2) + m(4,2),
				 m(3,3) + m(4,3),
				 m(3,4) + m(4,4));
	pl[FARP].setCoefficients( 
				-m(3,1) + m(4,1),
				-m(3,2) + m(4,2),
				-m(3,3) + m(4,3),
				-m(3,4) + m(4,4));
	pl[BOTTOM].setCoefficients(
				 m(2,1) + m(4,1),
				 m(2,2) + m(4,2),
				 m(2,3) + m(4,3),
				 m(2,4) + m(4,4));
	pl[TOP].setCoefficients(  
				-m(2,1) + m(4,1),
				-m(2,2) + m(4,2),
				-m(2,3) + m(4,3),
				-m(2,4) + m(4,4));
	pl[LEFT].setCoefficients(  
				 m(1,1) + m(4,1),
				 m(1,2) + m(4,2),
				 m(1,3) + m(4,3),
				 m(1,4) + m(4,4));
	pl[RIGHT].setCoefficients(
				-m(1,1) + m(4,1),
				-m(1,2) + m(4,2),
				-m(1,3) + m(4,3),
				-m(1,4) + m(4,4));
}

#undef M
</code>
</pre>
The function <i>setCoefficients</i> from the class Plane is as follows:
<pre><code>
void Plane::setCoefficients(float a, float b, float c, float d) {

	// set the normal vector
	normal.set(a,b,c);
	//compute the lenght of the vector
	float l = normal.length();
	// normalize the vector
	normal.set(a/l,b/l,c/l);
	// and divide d by th length as well
	this-&gt;d = d/l;
}
</code>
</pre>
To extract the matrices M and P from OpenGL state the function glGetFloatv can be used:
<pre><code>
	float m[16],p[16];

	glGetFloatv(GL_PROJECTION_MATRIX,p);
	glGetFloatv(GL_MODELVIEW_MATRIX,m);
</code>
</pre>
Matrix multiplication is then performed to compute A = M*P. A simple matrix multiplication such as the one below will do:
<pre><code>
void multMat(float *res,float *a, float *b) {


	for (int i=0;i&lt;4;i++) {
		for (int j = 0;j &lt; 4;j++) {
			res[i*4+j] = 0.0;
			for (int k = 0; k &lt; 4; k++) {
				res[i*4+j] += a[i*4+k] * b[k*4+j];
			}
		}
	}
}
</code>
</pre>
The following is a solution for lazy people, using OpenGL to perform the
 multiplication for you (in my laptop it is actually slightly faster!) :
<pre><code>
void multMat2(float *res, float *a, float *b) {

	glPushMatrix();

	glLoadMatrixf(b);
	glMultMatrixf(a);
	glGetFloatv(GL_MODELVIEW_MATRIX, res);

	glPopMatrix();
}
</code>
</pre>
Once the planes are extracted, testing points, spheres or boxes, works exactly as in the geometric approach.
<p>
</p><p>






</p><h2>
<center>
			Radar Approach - Testing Points
</center>
</h2>
<br>
The approaches presented in the previous sections were based on the fact
 that the volume of the view frustum is delimited by six planes. In 
those approaches the setup phase was responsible for extracting the 
planes equations, and testing was performed against the six planes. In 
this section a different approach is taken. This method is based on an 
article in <a href="https://cgvr.cs.uni-bremen.de/teaching/cg_literatur/lighthouse3d_view_frustum_culling/index5740.html?refs">Game Programming Gems 5</a> where the origin of the name are explained.
<p>

Consider that the camera has a referential based on the three unit vectors: <i>X</i>, <i>Y</i> and <i>Z</i>
 as shown in the next figure. Notice that the referential in the figure 
is not a right hand system (as in OpenGL), because the orientation of Z 
has been reversed to make the tutorial more intuitive. 
</p><p>
For a given point <i>p</i> to be tested against the view frustum, the 
goal is to find its coordinates in this referential and then use this 
information to find out if the point is inside or outside the frustum.
</p><p>
</p><center>
<img src="View%20Frustum%20Culling%20Tutorial_files/camsref.gif" width="480" height="236"> 
</center>
<p>
First the <i>Z</i> coordinate is checked. If the <i>Z</i> coordinate is not between the values of <i>nearDist</i> and <i>farDist</i> then the point is certainly outside of the view frustum, otherwise coordinates <i>X</i> and <i>Y</i> must be tested.
</p><p>
</p><center>
<img src="View%20Frustum%20Culling%20Tutorial_files/camsZ.gif" width="492" height="241"> 
</center>
<p>
In the image above, <i>p</i> is the point being tested. Consider <i>pc</i> as being the point <i>p</i> in  camera referential coordinates. In order to find the Z coordinate of <i>pc</i>, <i>pc.z</i> first it is necessary to find the vector that goes from <i>cc</i> (the camera center) to <i>p</i>, and then the length of the projection of this vector on <i>Z</i> (the projection is the blue point) must be computed. As shown in the <a href="http://www.lighthouse3d.com/opengl/maths/index.php?lines">lines</a> section of the maths tutorial, this can be done with a <a href="http://www.lighthouse3d.com/opengl/maths/index.php?innerproduct">dot product</a> (this is valid because it is assumed that <i>Z</i> is a unit vector), hence:
</p><pre><code>	<i>v</i> = <i>p</i> - <i>cc</i>
	<i>pc.z</i> = <i>v</i> . Z
</code>
</pre>
If <i>pc.z</i> is not between <i>nearDist</i> and <i>farDist</i> then <i>p</i> is outside the frustum.
<pre><code>	if (pc.z &gt; farDist || pc.z &lt; nearDist) 
			return (OUTSIDE);
</code>
</pre>
Up to this point the value of <i>pc.z</i> is known, where <i>pc</i> is the value of point <i>p</i> in the camera referential coordinates. To find <i>pc.y</i> and <i>pc.x</i> a similar procedure is used: find the length of the projection of vector <i>v</i> in both the Y and X axis respectively.
<pre><code>	<i>v</i> = <i>p</i> - <i>cc</i>
	<i>pc.z</i> = <i>v</i> . Z
	<i>pc.y</i> = <i>v</i> . Y
	<i>pc.x</i> = <i>v</i> . X
</code>
</pre>


<p>



</p><h2>
<center>
			Radar Approach - Testing Points II
</center>
</h2>
<br>
Up to this point the required computations to compute the value of <i>p</i> in the camera referential coordinates, <i>pc</i> have been detailed. It is also assumed at this point that the pc.z has a value that is between <i>nearDist</i> and <i>farDist</i>, so its time to check the other coordinates, namely <i>pc.y</i> and <i>pc.x</i>. 
<p>
Consider now a side view of the frustum in 2D to simplify the diagram. The horizontal arrow shows the value of <i>pc.z</i>. At that distance from the camera, <i>pc.z</i> the view frustum has a height <i>h</i>.
</p><p>
</p><center>
<img src="View%20Frustum%20Culling%20Tutorial_files/camseq1.gif" width="366" height="106"> 
</center>
<p>
where <i>a</i> is the horizontal field of view angle.
</p><p>
This implies that, for the Y coordinate of <i>pc</i> to be inside the view frustum,
</p><pre><code>	<i>-h/2</i> &lt; <i>pc.y</i> &lt;  <i>h/2</i>
</code>
</pre>
or, as an algorithm,
<pre><code>	if (-h/2 &gt; pc.y || pc.y  &gt;  h/2)
		return(OUTSIDE)
</code>
</pre>
The <a href="https://cgvr.cs.uni-bremen.de/teaching/cg_literatur/lighthouse3d_view_frustum_culling/index1ec6.html?defvf">width</a> of the frustum can be computed based on the height as 
<pre><code>	<i>w</i> = <i>h</i> * <i>ratio</i>;
</code>
</pre>
So the X component of pc can be tested with the following <i>if</i> statement:
<pre><code>	if (-w/2 &gt; pc.x || pc.x  &gt;  w/2)
		return(OUTSIDE)
</code>
</pre>
The following figure, although a little bit complex ( ;-&gt; ) provides some information about the components of <i>pc</i>.
<p>
</p><center>
<img src="View%20Frustum%20Culling%20Tutorial_files/camsX.gif" width="498" height="358"> 
</center>
<p>

This method should be faster than the previous approaches where six 
planes are tested. In here, only a dot product is performed for each 
pair of planes, whereas in the previous approaches a dot product was 
performed for every plane, in the worst case scenario. See the next 
section for an implementation.
</p><p>





</p><h2>
<center>
			Radar Approach - Implementation
</center>
</h2>
<br>
A class to implement the frustum functionality based on the radar 
approach is now presented. Note that the code itself is not optimized in
 any way, as the goal is only to serve as the tutorial companion. As 
opposed to the previous implementations, this class contains only the 
required data to make it work. 
<p>
<b>The class header file</b>
</p><pre><code>
class FrustumR{


public:

	static enum {OUTSIDE, INTERSECT, INSIDE};

	Vec3 cc; // camera position
	Vec3 X,Y,Z; // the camera referential
	float nearD, farD, width, height;

	FrustumR::FrustumR();
	FrustumR::~FrustumR();

	void setCamInternals(float angle, float ratio, float nearD, float farD);
	void setCamDef(Vec3 &amp;p, Vec3 &amp;l, Vec3 &amp;u);
	int pointInFrustum(Vec3 &amp;p);

};
</code>
</pre>
<p>
<b>The Methods: setCamInternals</b>
</p><p>
This function takes exactly the same parameters as the function <i>gluPerspective</i>. Each time the perspective definitions change, for instance when a window is resized, this function should be called as well.
</p><pre><code>
#define ANG2RAD 3.14159265358979323846/180.0

void FrustumR::setCamInternals(float angle, float ratio, float nearD, float farD) {

	// store the information
	this-&gt;ratio = ratio;
	this-&gt;nearD = nearD;
	this-&gt;farD = farD;

	// compute width and height of the near section
	tang = (float)tan(ANG2RAD * angle * 0.5) ;
	heigth = nearD * tang;
	width = height * ratio;


}
</code>
</pre>
<p>
The function stores all the information, and computes the width and 
height of the rectangular sections of the near plane and stores them in <i>height</i> (near height) and <i>width</i> (near width).
</p><p>
<b>The Methods: setCamDef</b>
</p><p>
This function takes three vectors that contain the information for the <i>gluLookAt</i>
 function: the position of the camera, a point to where the camera is 
pointing and the up vector. Each time the camera position or orientation
 changes, this function should be called as well. Notice how the 
following function is much simpler than for the other methods of view 
frustum culling. There is no need to compute the planes anymore.
</p><pre><code>
void FrustumR::setCamDef(Vec3 &amp;p, Vec3 &amp;l, Vec3 &amp;u) {

	cc = p.copy();
	
	// compute the Z axis of the camera referential
	// this axis points in the same direction from 
	// the looking direction
	Z = l - p;
	Z.normalize();

	// X axis of camera with given "up" vector and Z axis
	X = Z * u;
	X.normalize();

	// the real "up" vector is the dot product of X and Z
	Y = X * Z;
}
</code>
</pre>
<p>
<b>The Methods: pointInFrustum</b>
</p><p>
Testing a point is also much simpler and more efficient:
</p><pre><code>

int FrustumR::pointInFrustum(Vec3 &amp;p) {
		
	float pcz,pcx,pcy,aux;

	// compute vector from camera position to p
	Vec3 v = p-camPos;

	// compute and test the Z coordinate
	pcz = v.innerProduct(-Z);
	if (pcz &gt; farD || pcz &lt; nearD)
		return(OUTSIDE);

	// compute and test the Y coordinate
	pcy = v.innerProduct(Y);
	aux = pcz * tang;
	if (pcy &gt; aux || pcy &lt; -aux)
		return(OUTSIDE);
		
	// compute and test the X coordinate
	pcx = v.innerProduct(X);
	aux = aux * ratio;
	if (pcx &gt; aux || pcx &lt; -aux)
		return(OUTSIDE);


	return(INSIDE);
}
</code>
</pre>
<p>



</p><h2>
<center>
			Radar Approach - Testing Spheres
</center>
</h2>
<br>
Under the radar approach testing spheres is far more complicated than 
with the other methods, but nonetheless still more efficient. 
<p>
Let's start with the Z component. A sphere has a center <i>c</i> and a radius <i>r</i>.
 The Z component is the easiest of them all, and it must be performed 
first since it is required to know the z value of the camera center in 
the camera referential.
</p><p>
First it is necessary to compute the z component of the sphere center in camera coordinates and this is performed as shown <a href="https://cgvr.cs.uni-bremen.de/teaching/cg_literatur/lighthouse3d_view_frustum_culling/index5ec2.html?camspace">before</a>.
</p><pre><code>	<i>v</i> = <i>p</i> - <i>cc</i>
	<i>pc.z</i> = <i>v</i> . Z
</code>
</pre>
The only difference in Z testing is the inclusion of the radius in the test condition. If <i>pc.z</i> is not between <i>nearDist-r</i> and <i>farDist+r</i> then <i>p</i> is outside the frustum.
<pre><code>	if (pc.z &gt; farDist +r || pc.z &lt; nearDist - r) 
			return (OUTSIDE);
</code>
</pre>
Testing for interception can be achieved afterwards with the following code:
<pre><code>	if (pc.z &gt; farDist - r || pc.z &lt; nearDist + r) 
			result = INTERSECT;
</code>
</pre>
Note that when the sphere is outside (red sphere) any of the given 
planes the testing can terminate, hence the return statement. However an
 intersection (orange sphere) with the near or far planes is 
inconclusive without testing the other coordinates first, therefore only
 the variable <i>result</i> is set in this case.
<p>
</p><center>
<img src="View%20Frustum%20Culling%20Tutorial_files/camsphere.gif" width="464" height="348">
</center>
<p>
Testing both <i>x</i> and <i>y</i> components is the delicate part. When both the <i>x</i> and <i>y</i> components are inside the frustum (the figure below shows only the <i>Y</i> axis) then the sphere is at least intersecting the frustum. 
</p><p>
</p><center>
<img src="View%20Frustum%20Culling%20Tutorial_files/camsphere2.gif" width="544" height="335">
</center>
<p>
But when is it totally inside, or outside? Consider the following figure
 where only the top plane is depicted to make the diagram simpler.
</p><p>
</p><center>
<img src="View%20Frustum%20Culling%20Tutorial_files/camsphere3.gif" width="363" height="231">
</center>
<p>
If the only difference comparing to testing points would be the 
inclusion of the radius, then the sphere in the figure above would be 
outside when it clearly intersects the frustum. So the following code is
 <u>not</u> accurate:
</p><pre><code>	if (pc.z &gt; h/2 + r || pc.z &lt; - h/2 - r) 
			return (OUTSIDE);
</code>
</pre>
The following figure shows that the distance we're looking for is not the radius <i>r</i> of the sphere but <i>d</i>.
<p>
</p><center>
<img src="View%20Frustum%20Culling%20Tutorial_files/camsphere4.gif" width="340" height="258">
</center>
<p>
Fortunately <i>d</i> can be computed as a function of the radius and 
half the horizontal field of view angle (alpha in the figure). The angle
 between the vectors with the directions <i>r</i> and <i>d</i> is equal to alpha, hence:
</p><pre><code>	d = r / cos(alpha)
</code>
</pre>
Since <i>alpha</i> is know a priori, the term 1/cos(alpha) can be 
precomputed so  the extra computational effort during testing is only a 
multiplication by the radius. This term, hereafter named the <i>sphereFactorY</i>, needs to be computed when the perspective is set. A similar term for the X axis, <i>sphereFactorX</i>,
 is also required since the angle is potentially different (unless the 
ratio between width and height of the viewport is 1). The next section 
shows the implementation details.
<p>




</p><h2>
<center>
			Radar Approach - Implementation II
</center>
</h2>
<br>
This section presents an implementation for sphere testing against the 
view frustum under the radar approach. The class definition is presented
 in here again, now with the new data required to test spheres. The 
differences from the <a href="https://cgvr.cs.uni-bremen.de/teaching/cg_literatur/lighthouse3d_view_frustum_culling/indexf2cb.html?rimp">previous</a> implementation are properly commented.
<p>
<b>The class header file</b>
</p><pre><code>
class FrustumR{


public:

	static enum {OUTSIDE, INTERSECT, INSIDE};

	Vec3 cc; // camera position
	Vec3 X,Y,Z;// the camera referential
	float nearD, farD, width, height;
	
	// NEW: these are the variables required to test spheres
	float sphereFactorX, sphereFactorY;

	FrustumR::FrustumR();
	FrustumR::~FrustumR();

	void setCamInternals(float angle, float ratio, float nearD, float farD);
	void setCamDef(Vec3 &amp;p, Vec3 &amp;l, Vec3 &amp;u);
	int pointInFrustum(Vec3 &amp;p);
	
	// NEW: function to test spheres
	int sphereInFrustum(Vec3 ¢er, float radius);

};
</code>
</pre>
<p>
<b>The Methods: setCamInternals</b>
</p><p>
This function is similar to the one presented <a href="https://cgvr.cs.uni-bremen.de/teaching/cg_literatur/lighthouse3d_view_frustum_culling/indexf2cb.html?rimp">before</a>, adding only the computation of sphere factors.
</p><pre><code>
#define ANG2RAD 3.14159265358979323846/180.0

void FrustumR::setCamInternals(float angle, float ratio, float nearD, float farD) {

	// half of the the horizontal field of view
	float angleX;
	// store the information
	this-&gt;ratio = ratio;
	this-&gt;nearD = nearD;
	this-&gt;farD = farD;
	
	angle *= ANG2RAD;
	// compute width and height of the near and far plane sections
	tang = tan(angle);
	sphereFactorY = 1.0/cos(angle);

	// compute half of the the horizontal field of view and sphereFactorX 
	float anglex = atan(tang*ratio);
	sphereFactorX = 1.0/cos(anglex); 
}
</code>
</pre>
<p>
</p><p>
<b>The Methods: sphereInFrustum</b>
</p><p>
This function takes the center of the sphere and its radius and tests the sphere against the view frustum.
</p><pre><code>
int FrustumR::sphereInFrustum(Vec3 &amp;p, float radius) {

	float d;
	float az,ax,ay;
	int result = INSIDE;

	Vec3 v = p-camPos;

	az = v.innerProduct(-Z);
	if (az &gt; farD + radius || az &lt; nearD-radius)
		return(OUTSIDE);
	if (az &gt; farD - radius || az &lt; nearD+radius)
		result = INTERSECT;

	ay = v.innerProduct(Y);
	d = sphereFactorY * radius;
	az *= tang;
	if (ay &gt; az+d || ay &lt; -az-d)
		return(OUTSIDE);
	if (ay &gt; az-d || ay &lt; -az+d)
		result = INTERSECT;

	ax = v.innerProduct(X);
	az *= ratio;
	d = sphereFactorX * radius;
	if (ax &gt; az+d || ax &lt; -az-d)
		return(OUTSIDE);
	if (ax &gt; az-d || ax &lt; -az+d)
		result = INTERSECT;

	return(result);
</code>
</pre><p>






</p><h2>
<center>
			Radar Approach - Source Code
</center>
</h2>
<br>
The <a href="https://cgvr.cs.uni-bremen.de/teaching/cg_literatur/lighthouse3d_view_frustum_culling/examples/frustumR.zip">zip</a>
 file contains the source code and a VC 6.0 project. The project 
contains all classes that are required to run the test, and allows 
testing with points and spheres. The source is more complete than the 
code presented in the tutorial since it includes the computation of 
several variables that can be used for debugging purposes, for instance 
the eight corners of the tutorials, the eight planes and respective 
normals, etc...

Try it and see the difference between the frames per second achieved 
with and without frustum culling.
<p>
Note: the fps counter is only altered once per second, so keep your fingers on a leash :-)
</p><p>
As usual the source code is provided as a companion for this tutorial, 
and it could be optimized in many ways. Also there is no guarantee that 
it is bug free, or that it will run everywhere. 
</p><p>
Having said this, if you find a bug, or some way to improve this 
(without much work :), or even if you create a port to some other 
operating system, please let me know.
</p><p>



</p><h2>
<center>
			Some Notes and Possible Optimizations	
</center>
</h2>
<br>
<b>Spheres as Bounding Volumes for Boxes</b>
<p>
As shown throughout this tutorial is easier to do tests with spheres 
than it is with boxes. Therefore, if a large number of boxes will 
normally be outside the view frustum, then a bounding sphere should be 
considered as a possible optimization. Testing a sphere requires only a 
distance computation against more complex calculations for the box case.
</p><p>
</p><center>
<img src="View%20Frustum%20Culling%20Tutorial_files/vfboxsphere.gif" width="308" height="293">
</center>
<p>
If the sphere is totally outside of the frustum (case A) then the box is
 also totally outside the box. If the sphere is totally inside the 
frustum so must be the box (case B). When the sphere intersects the 
frustum walls two options are available: consider that the box also 
intersects, which may be false (case C), or test the box itself. 
</p><p>
Only in this latter case, sphere intersecting the frustum walls, there 
is a penalization for using a sphere as a bounding volume for the box. 
In all the other cases the test is faster. Note that this optimization 
should be used with care when considering long skinny boxes, since in 
this case a sphere is not the best bounding volume.
</p><p>
<b>Spheres everywhere</b>
</p><p>
Sphere-sphere test is also very fast: just sum the radius of both 
spheres and compute the distance between the two centers. If the 
distance is larger than the sum of the radius then the spheres are 
separated. 
</p><p>
Based on this, one could consider a bounding sphere for the frustum 
itself. Then a first test would be to check if the object's bounding 
sphere is outside the frustum's bounding sphere, and in this case reject
 the object immediately.
</p><p>
However this test should be used with care since the sphere that is 
bounding the view frustum is significantly larger than the frustum 
itself. Nevertheless if the frustum is small compared to the 3D world 
then it makes sense to use this as an initial test.
</p><p>
<b>Axis-Aligned Boxes everywhere</b>
</p><p>
Computing an AAB as a bounding volume for an object (or frustum) is 
extremely easy, just compute the minima and maxima for each axis. 
</p><p>
Testing if something is inside of an AAB is also very simple and it 
doesn't involve distance computations. Just check if there are overlaps 
on each axis. Consider an AAB bounding volume, or just AABB, for the 
frustum, <i>fb</i> and an AABB for an object <i>ob</i>. The following algorithm performs the intersection test:
</p><pre><code>
if (fb_xmin &gt; ob_xmax || fb_xmax &lt; ob_xmin ||
	fb_ymin &gt; ob_ymax || fb_ymax &lt; ob_ymin ||
	fb_zmin &gt; ob_zmax || fb_zmax &lt; ob_zmin)
	
	return (OUTSIDE);
	
else if (fb_xmin &lt; ob_xmin &amp;&amp; fb_xmax &gt; ob_xmax &amp;&amp;
		 fb_ymin &lt; ob_ymin &amp;&amp; fb_ymax &gt; ob_ymax &amp;&amp;
		 fb_zmin &lt; ob_zmin &amp;&amp; fb_zmax &gt; ob_zmax)
	return (INSIDE);
else
	return(INTERSECT);
	
</code>
</pre>
If the result is OUTSIDE the case is closed. Otherwise, when the result 
is INTERSECT or INSIDE, then further testing is required.
<p>
 As for the case when a sphere was proposed as a bounding volume for the
 view frustum, some care must be taken to check if a bounding box is an 
appropriate bounding volume for the view frustum. Oblique, long and 
skinny frusta are not particularly suited.
</p><p>
<b>Floats and precision (or lack of it)</b>
</p><p>
When computing the relative position of objects regarding the frustum in
 this tutorial comparisations such as "
&gt; 0" or " &lt; 0" were used. Note that due to the limited precision 
of numbers in computers something that is slightly outside of frustum 
may be reported as inside, and vice-versa. It will only happen when 
there is a very close call, but it will happen eventually. Two 
solutions: never mind because these cases are such a close call that no 
one cares; be extra conservative and give a tolerance, i.e. consider a 
slightly larger frustum. 
</p><p>
This latter solution, increasing the frustum can be achieved in several ways. For instance the planes themselves
can be pushed a little bit further away, inflating the view frustum, by adding a small vector ( a fraction of the
plane's normal) to the points that define the plane. Another solution is to change the way the comparisons are
performed, for instance instead fo testing " &lt; 0" test " &lt; -0.001".
</p><p>
Precision increase is possible using doubles instead of floats, but all the math for the tests becomes more expensive. 
</p><p>
</p><p>





</p><h2>
<center>
			Further Optimization	
</center>
</h2>
<br>
It is possible to optimize the view frustum culling process taking in 
account spatial and temporal coherence. These optimizations we're first 
proposed by <a href="https://cgvr.cs.uni-bremen.de/teaching/cg_literatur/lighthouse3d_view_frustum_culling/index5740.html?refs">Assarsson and Moller</a>. Do have a look at their paper if you're really into this.
<p>
<b>Plane Coherence</b>
</p><p>
If an object is rejected by a plane, and the camera moves slowly it is 
likely that the object will be rejected by the same plane again. If this
 is true then the first plane to be tested should be the one that led to
 rejection in the previous frame. To implement this strategy it is 
enough to store in each object the last plane of rejection. 
</p><p>
This reasoning can be detailed observing the type of movements performed
 by the view frustum. Assarsson and Moller consider the two 
possibilities separately: rotation and translation.
</p><p>
<b>Rotation Coherence</b>
</p><p>
This approach is based on the camera's rotation. When an object is 
rejected by the left plane and the camera rotates a little to the right 
then the object will be out of frustum again.
</p><p>
</p><center>
<img src="View%20Frustum%20Culling%20Tutorial_files/remrot.gif" width="465" height="216">
</center>
<p>
However this approach should be used with caution. If the camera keeps 
rotating to the right, the object will eventually be inside the view 
frustum again. 
</p><p>
If the rotation is not restricted to any of the axes it is hard to keep 
track of it, hence it is probably simpler to use a timestamp, and keep 
the record of the plane only for a small amount of time.
</p><p>
<b>Translation Coherence</b>
</p><p>
If an object is rejected by the near plane, i.e. it is behind the view 
frustum, and the camera translates forward then that object will be out 
of the view frustum for sure. 
</p><p>
When the view frustum is translated, the planes are translated by a 
certain distance (a different distance for each plane in the general 
case). Lets assume that when the view frustum was translated, the left 
plane was translated by <i>d</i>, where <i>d</i> is the signed distance between the left planes in two consecutive frames. Then if a bounding volume was at a signed distance <i>d0</i> in the last frame, in the present frame the distance from the bounding volume to the left plane will be <i>d'</i> = <i>d + d0</i>. 
</p><p>
</p><center>
<img src="View%20Frustum%20Culling%20Tutorial_files/remtrans.gif" width="216" height="157">
</center>
<p>
This approach can only be applied if the distances from the bounding 
volume to the planes are kept, which requires extra storage to keep 
them. Furthermore, since the bounding volume is not necessarily tested 
against all the frustum's planes (or tested at all) these distances may 
be unknown.
</p><p>
<b>Conclusion</b>
</p><p>
Several methods and optimizations we're presented in this tutorial. 
There are many solutions and often they present a trade-off between the 
accuracy of the test and its computational expense.
</p><p>
One thing to have in mind is that plane extraction is going to be 
performed once every time the camera moves. On the other hand testing is
 going to be performed <i>n</i> times per frame (<i>n</i> being the number of things to test) and <i>n</i>
 can be quite large. So to optimize view frustum culling, the main focus
 should be on the testing side, as this is going to take the lion's 
share of the time taken to perform view frustum culling.</p><p>
To properly tune an application requires testing and measuring times, 
and a good degree of feeling. Hope the tutorial has helped someone out 
there to get a better grasp of the view frustum culling process.

</p><p>





</p><h2>
<center>
			References
</center>
</h2>
<br>
There is a lot of material out there and you may want to explore it 
further, so here are a few pointers both for printed material as well as
 online stuff.
<p>
The book from Moller and Haines, <a href="http://www.amazon.com/exec/obidos/ASIN/1568811829/3dtech/">Real-Time Rendering 2nd ed.</a>, is a very complete source of information.
</p><p>
Assarson and Moller wrote an article on this subject <a href="https://cgvr.cs.uni-bremen.de/www.ce.chalmers.se/_uffe/vfc_bbox.pdf">Optimized View Frustum Culling
Algorithms for Bounding Boxes</a>, published in the Journal of Graphic Tools where most of the optimizations mentioned here are presented.
</p><p>
The document from Gribb and Hartmann, entitled <a href="https://cgvr.cs.uni-bremen.de/www2.ravensoft.com/users/ggribb/plane%20extraction.pdf">Fast Extraction of Viewing Frustum Planes from the World-
View-Projection Matrix</a> has been around for some time and explores 
the extraction phase of the view frustum planes both for OpenGL (as 
detailed in this tutorial) and Direct3D.
</p><p>
Mark Morley had a document called Frustum Culling in OpenGL, but I can't find it anymore. It used to be <a href="http://www.markmorley.com/">here</a>.
</p><p>
Daniel Sýkora and Josef Jelínek have published a work entitled <a href="http://www.cg.tuwien.ac.at/studentwork/CESCG/CESCG-2002/DSykoraJJelinek/">Efficient View Frustum Culling</a> where besides providing information about the view frustum culling process, also provide test results on some optimizations.
</p><p>
Eric Lengyel, in the book <a href="http://www.amazon.com/exec/obidos/ASIN/1584502770/3dtech/">Mathematics for 3D game programming and Computer Graphics</a> has a section on plane extraction.
</p><p>
Dion Picco has written an article for Flipcode called <a href="http://www.flipcode.com/articles/article_frustumculling.shtml">Frustum Culling</a> where some optimizations for the testing phase are discussed.
</p><p>
<a href="http://www.amazon.com/exec/obidos/ASIN/1584503521/3dtech/">Game Programming Gems 5</a> has an article by Frank Puig Placeres, entitled "Improved Frustum Culling" where the "radar approach" is introduced.
</p><p>










</p></body><!-- Mirrored from www.lighthouse3d.com/opengl/viewfrustum/index.php?gimp by HTTrack Website Copier/3.x [XR&CO'2006], Thu, 18 Jan 2007 07:56:21 GMT --><style type="text/css"></style></html>